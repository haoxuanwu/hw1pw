#Homework 1
library(ggplot2)
library(doParallel)
library(MASS)
library(leaps)
library(glmnet)
registerDoParallel(cores=7)

{
#Problem 1 Part 1
#Alpha = 1
A = matrix(0, nrow = 100, ncol=100)
diag(A) = rep(1, 100)
index = seq(1, 99)
A[cbind(index+1, index)] = rep(-1, 99)
A[cbind(index, index+1)] = rep(-1, 99)
spec_norm = max(sqrt(eigen(t(A)%*%A)$values))
#Check spectral radius for Jacobi
D = diag(rep(1, 100))
R = A - D
max(eigen(D%*%R)$values)
#Spectral radius for Gauss-Seidel
L = matrix(0, nrow = 100, ncol=100)
L[cbind(index+1, index)] = rep(-1, 99)
U = matrix(0, nrow = 100, ncol=100)
U[cbind(index, index+1)] = rep(-1, 99)
max(abs(eigen(solve(L+D)%*%U)$values))

#Alpha = 2
diag(A) = rep(2, 100)
spec_norm = max(sqrt(eigen(t(A)%*%A)$values))
#Check spectral radius for Jacobi
D = diag(rep(2, 100))
R = A - D
max(abs(eigen(diag(rep(1/2, 100))%*%R)$values))
#Spectral radius for Gauss-Seidel
max(abs(eigen(solve(L+D)%*%U)$values))

#Alpha = 3
diag(A) = rep(3, 100)
spec_norm = max(sqrt(eigen(t(A)%*%A)$values))
#Check spectral radius
D = diag(rep(3, 100))
R = A - D
max(abs(eigen(diag(rep(1/3, 100))%*%R)$values))
#Spectral radius for Gauss-Seidel
max(abs(eigen(solve(L+D)%*%U)$values))


#Problem 1 Part b
#Gauss-Seidel
gauss_seidel = function(A, b, v, iteration=10000){
  x = matrix(0, nrow=length(b))
  rel_err = c()
  time = c()
  timer0 = proc.time()[3]
  for (iter in 1:iteration) {
    for (i in 1:length(b)){
      temp = 0
      for (j in 1:length(b)){
        if (j != i) {
          temp = temp + A[i, j]*x[j]
        }
      }
      x[i] = 1/A[i,i]*(b[i]-temp)
    }
    rel_err[iter] = norm(x-v, type="2")/norm(v, type="2")
    time[iter] = round(proc.time()[3] - timer0, digits=3)
  }
  list(x = x, rel_err = rel_err, time = time)
}

jacobi = function(A, b, v, iteration=10000){
  x = matrix(0, nrow=length(b))
  rel_err = c()
  time = c()
  timer0 = proc.time()[3]
  for (iter in 1:iteration) {
    temp_x = x
    for (i in 1:length(b)){
      temp = 0
      for (j in 1:length(b)){
        if (j != i) {
          temp = temp + A[i, j]*temp_x[j]
        }
      }
      x[i] = 1/A[i,i]*(b[i]-temp)
    }
    rel_err[iter] = norm(x-v, type="2")/norm(v, type="2")
    time[iter] = round(proc.time()[3] - timer0, digits=3)
  }
  list(x = x, rel_err = rel_err, time = time)
}

jacobi_par = function(A, b, v, iteration=10000){
  x = matrix(0, nrow=length(b))
  rel_err = c()
  time = c()
  timer0 = proc.time()[3]
  for (iter in 1:iteration) {
    print(iter)
    temp_x = x
    x = foreach(i = 1:length(b), .combine=c) %dopar% {
      temp = 0
      for (j in 1:length(b)){
        if (j != i) {
          temp = temp + A[i, j]*temp_x[j]
        }
      }
      1/A[i,i]*(b[i]-temp)
    }
    rel_err[iter] = norm(x-v, type="2")/norm(v, type="2")
    time[iter] = round(proc.time()[3] - timer0, digits=3)
  }
  list(x = x, rel_err = rel_err, time = time)
}


#Alpha = 1
diag(A) = rep(2, 100)
v = matrix(rep(1,100), nrow=100)
b = A %*% v
g_res_1 = gauss_seidel(A, b, v)
j_res_1 = jacobi(A, b, v)
j_par_res_1 = jacobi_par(A, b, v)
par(mfrow=c(1,3))
plot(g_res_1$rel_err, type="l", ylab="Relative Error", xlab="Iterations", main="Gauss Seidel (alpha=1)")
plot(j_res_1$rel_err, col="blue", type="l", ylab="Relative Error", xlab="Iterations", main="Jacobi (alpha=1)")
plot(j_par_res_1$rel_err, col="red", type="l",  ylab="Relative Error", xlab="Iterations", main="Jacobi Parallel (alpha=1)")
plot(g_res_1$time, g_res_1$rel_err, type="l", ylab="Relative Error", xlab="Time (in seconds)", main="Gauss Seidel (alpha=1)")
plot(j_res_1$time, j_res_1$rel_err, type="l", ylab="Relative Error", xlab="Time (in seconds)", main="Jacobi (alpha=1)")
plot(j_par_res_1$time, j_par_res_1$rel_err, type="l", ylab="Relative Error", xlab="Time (in seconds)", main="Jacobi Parallel (alpha=1)")
par(mfrow=c(1,1))


#Alpha = 2
diag(A) = rep(2, 100)
b = A %*% v
g_res = gauss_seidel(A, b, v)
j_res = jacobi(A, b, v)
j_par_res = jacobi_par(A, b, v)
par(mfrow=c(1,3))
plot(g_res$rel_err, type="l", ylab="Relative Error", xlab="Iterations", main="Gauss Seidel (alpha=2)")
plot(j_res$rel_err, col="blue", type="l", ylab="Relative Error", xlab="Iterations", main="Jacobi (alpha=2)")
plot(j_par_res$rel_err, col="red", type="l",  ylab="Relative Error", xlab="Iterations", main="Jacobi Parallel (alpha=2)")
plot(g_res$time, g_res$rel_err, type="l", ylab="Relative Error", xlab="Time (in seconds)", main="Gauss Seidel (alpha=2)")
plot(j_res$time, j_res$rel_err, type="l", ylab="Relative Error", xlab="Time (in seconds)", main="Jacobi (alpha=2)")
plot(j_par_res$time, j_par_res$rel_err, type="l", ylab="Relative Error", xlab="Time (in seconds)", main="Jacobi Parallel (alpha=2)")
par(mfrow=c(1,1))

#Alpha = 3
diag(A) = rep(3, 100)
b = A %*% v
g_res_3 = gauss_seidel(A, b, v)
j_res_3 = jacobi(A, b, v)
j_par_res_3 = jacobi_par(A, b, v)
plot(g_res_3$rel_err, type="l")
lines(j_res_3$rel_err, col="blue")
lines(j_par_res_3$rel_err, col="red")
par(mfrow=c(1,3))
plot(g_res_3$rel_err, type="l", ylab="Relative Error", xlab="Iterations", main="Gauss Seidel (alpha=3)")
plot(j_res_3$rel_err, col="blue", type="l", ylab="Relative Error", xlab="Iterations", main="Jacobi (alpha=3)")
plot(j_par_res_3$rel_err, col="red", type="l",  ylab="Relative Error", xlab="Iterations", main="Jacobi Parallel (alpha=3)")
plot(g_res_3$time, g_res_3$rel_err, type="l", ylab="Relative Error", xlab="Time (in seconds)", main="Gauss Seidel (alpha=3)")
plot(j_res_3$time, j_res_3$rel_err, type="l", ylab="Relative Error", xlab="Time (in seconds)", main="Jacobi (alpha=3)")
plot(j_par_res_3$time, j_par_res_3$rel_err, type="l", ylab="Relative Error", xlab="Time (in seconds)", main="Jacobi Parallel (alpha=3)")
par(mfrow=c(1,1))

}

{
#Problem 2
unif_subs = function(y, X, r, plot=F) {
  prob = rep(1/(length(y)), length(y))
  samp = sample(seq(1, length(y)), r, prob = prob)
  data = data.frame(y = y[samp], X = X[samp])
  model = lm(y ~ X, data = data, weights = 1/prob[samp])
  if (plot) {
    plot(X, y, main="Uniform")
    points(X[samp], y[samp], col = "red", lwd=3)
    abline(a = model$coefficients[1], b = model$coefficients[2], col="red")
  }
  model$coefficients[2]
}

lev_subs = function(y, X, r, plot=F) {
  h = diag(X%*%solve(t(X)%*%X)%*%t(X))
  prob = h/sum(h)
  samp = sample(seq(1, length(y)), r, prob = prob)
  data = data.frame(y = y[samp], X = X[samp])
  model = lm(y ~ X, data = data, weights = 1/prob[samp])
  if (plot) {
    plot(X, y, main="Leverage")
    points(X[samp], y[samp], col = "red", lwd=3)
    abline(a = model$coefficients[1], b = model$coefficients[2], col="red")
  }
  model$coefficients[2]
}

X = matrix(rt(500, 6), nrow=500)
ep = matrix(rnorm(500, 0, 1), nrow=500)
y = -X + ep

for (r in c(10, 50, 100, 200, 300)){
  unif_res = c()
  lev_res = c()
  for (i in 1:500){
    unif_res[i] = unif_subs(y, X, r)
    lev_res[i] = lev_subs(y, X, r)
  }
  boxplot(abs(unif_res+1), abs(lev_res+1), names = c("Uniform", "Leverage"))
}
}

{
#Problem 3
e_net = function(X, y, alpha, lambda, eps=0.000001, init_beta = matrix(rep(0,dim(X)[2]), nrow = dim(X)[2])){
  beta = init_beta
  n = length(y)
  for (itr in 1:1000){
    beta_old = beta
    for (j in 1:20){
        temp = 0
        for (i in 1:n){
          temp = temp + 1/n*X[i,j]*(y[i]-X[i,]%*%beta+X[i,j]*beta[j])
        }
        beta[j] = sign(temp)*max(abs(temp)-lambda*alpha, 0)/(1+2*lambda*(1-alpha))
      }
    if (sum(abs(beta-beta_old))<eps){
      break
    }
  }
  beta
}

#Data Simulation
#Setting n and alpha
n = 100
alpha = 1

eps = matrix(rnorm(n, 0, 1), nrow=n)
sig = diag(rep(1, 20))
sig[1, 2] = 0.8; sig[2,1]= 0.8; sig[5,6] = 0.8; sig[6,5]=0.8
X = mvrnorm(n, mu=rep(0, 20), Sigma = sig)
X = scale(X)
beta = matrix(c(2,0,-2,0,1,0,-1,0,rep(0, 12)), nrow=20)
y = X%*%beta+eps

#Simulating Beta and Plotting List
max_val = c()
for (ind in 1:length(X[1,])){
  max_val[ind] = 1/length(y)*sum(abs(X[,ind]*y))
}
if (alpha==0){
  alpha_temp=0.01
} else{
  alpha_temp = alpha
}
lambda_max = max(max_val)/alpha_temp
lambda_min = 0.001*lambda_max

beta_list = matrix(rep(0,2000), ncol=100, nrow=20)
index = 1
for (lambda in seq(log(lambda_max), log(lambda_min), length.out = 100)){
  print(index)
  beta_list[,index] = e_net(X, y, alpha, exp(lambda))
  index =  index + 1
}

plot_x = c()
for (i in 1:10){
  plot_x = c(plot_x, beta_list[i,])
}
dataf = data.frame(x=rep(log(seq(lambda_max, lambda_min, length.out = 100)), 10), y=plot_x,
                   var=rep(paste0("X", 1:10), each=100))
ggplot(data = dataf, aes(x=x, y=y)) + geom_line(aes(colour=var))+ggtitle(paste0("alpha = ", alpha, " n= ", n))+xlab("Log Lambda")+ylab("Beta")

#Comparison
output = glmnet(X, y, lambda.min.ratio = 0.001, family="gaussian", alpha=alpha)
plot(output, xvar="lambda", main=paste0("Glmnet: alpha = ", alpha, " n= ", n))

}

#Problem 4
#Prediction function (as seen in textbook)
predict.regsubsets = function(object , newdata ,id ,...){
  form=as.formula(object$call[[2]])
  mat=model.matrix(form ,newdata)
  coefi=coef(object, id=id)
  xvars=names(coefi)
  mat[,xvars]%*%coefi
}

#5 fold cross-validation
five_f_err_list = c()
five_no_pred = c()
for (iter in 1:20){
  print(iter)
  n=1000
  eps = matrix(rnorm(n, 0, 1), nrow=n)
  sig = diag(rep(1, 20))
  sig[1, 2] = 0.8; sig[2,1]= 0.8; sig[5,6] = 0.8; sig[6,5]=0.8
  X = mvrnorm(n, mu=rep(0, 20), Sigma = sig)
  beta = matrix(c(2,0,-2,0,1,0,-1,0,rep(0, 12)), nrow=20)
  y = X%*%beta+eps

  test_n = 200
  eps_test = matrix(rnorm(test_n, 0, 1), nrow=test_n)
  X_test = mvrnorm(test_n, mu=rep(0, 20), Sigma = sig)
  y_test = X_test%*%beta+eps_test


  data4 = data.frame(y = y, X)
  data4_test = data.frame(y=y_test, X_test)

  k=5
  folds=sample(1:k,length(y),replace=TRUE)
  cv.errors = matrix(NA,k,20, dimnames =list(NULL, paste(1:20)))
  for(j in 1:k){
    best.fit=regsubsets(y ~ .,data=data4[folds!=j,], nvmax=20)
    for(i in 1:20){
        pred=predict(best.fit, data4[folds ==j,], id=i)
        cv.errors[j,i]= mean((data4$y[folds==j]-pred)^2)
      }
  }
  mean.cv.errors=apply(cv.errors ,2, mean)
  index = which(mean.cv.errors == min(mean.cv.errors))
  best.fit=regsubsets(y ~ .,data=data4, nvmax=20)
  pred=predict(best.fit, data4_test,id=index)
  five_f_err_list[iter] = mean((data4_test$y-pred)^2)
  five_no_pred[iter] = index
}
mean(five_f_err_list)
mean(five_no_pred)

#Leave 1 out cross-validation
one_f_err_list = c()
one_no_pred = c()
for (iter in 1:20){
  print(iter)
  n=1000
  eps = matrix(rnorm(n, 0, 1), nrow=n)
  sig = diag(rep(1, 20))
  sig[1, 2] = 0.8; sig[2,1]= 0.8; sig[5,6] = 0.8; sig[6,5]=0.8
  X = mvrnorm(n, mu=rep(0, 20), Sigma = sig)
  beta = matrix(c(2,0,-2,0,1,0,-1,0,rep(0, 12)), nrow=20)
  y = X%*%beta+eps

  test_n = 200
  eps_test = matrix(rnorm(test_n, 0, 1), nrow=test_n)
  X_test = mvrnorm(test_n, mu=rep(0, 20), Sigma = sig)
  y_test = X_test%*%beta+eps_test


  data4 = data.frame(y = y, X)
  data4_test = data.frame(y=y_test, X_test)

  k=100
  folds=seq(1,n)
  cv.errors = matrix(NA,k,20, dimnames =list(NULL, paste(1:20)))
  for(j in 1:k){
    best.fit=regsubsets(y ~ .,data=data4[folds!=j,], nvmax=20)
    for(i in 1:20){
      pred=predict(best.fit, data4[folds ==j,], id=i)
      cv.errors[j,i]= mean((data4$y[folds==j]-pred)^2)
    }
  }
  mean.cv.errors=apply(cv.errors ,2, mean)
  index = which(mean.cv.errors == min(mean.cv.errors))
  best.fit=regsubsets(y ~ .,data=data4, nvmax=20)
  pred=predict(best.fit, data4_test,id=index)
  one_f_err_list[iter] = mean((data4_test$y-pred)^2)
  one_no_pred[iter] = index
}
mean(one_f_err_list)
mean(one_no_pred)











